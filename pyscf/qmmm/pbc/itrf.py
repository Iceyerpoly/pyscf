import numpy as np
import pyscf
from pyscf import lib
from pyscf import gto
from pyscf import df
from pyscf import scf
from pyscf import grad
from pyscf.lib import logger
from pyscf.qmmm.pbc import mm_mole


def add_mm_charges(scf_method, atoms_or_coords, a, charges, radii=None, unit=None):
    '''Embedding the one-electron (non-relativistic) potential generated by MM
    point charges into QM Hamiltonian.

    The total energy includes the regular QM energy, the interaction between
    the nuclei in QM region and the MM charges, and the static Coulomb
    interaction between the electron density and the MM charges. The electrostatic
    interactions between reference cell and periodic images are also computed at
    point charge level. It does not include the static Coulomb interactions 
    of the MM point charges, the MM energy, the vdw interaction or other 
    bonding/non-bonding effects between QM region and MM particles.

    Args:
        scf_method : a HF or DFT object

        atoms_or_coords : 2D array, shape (N,3)
            MM particle coordinates
        charges : 1D array
            MM particle charges
        a : 1D array, shape (3)
            Box size

    Kwargs:
        radii : 1D array
            The Gaussian charge distribution radii of MM atoms.
        unit : str
            Bohr, AU, Ang (case insensitive). Default is the same to mol.unit

    Returns:
        Same method object as the input scf_method with modified 1e Hamiltonian

    Note:
        1. if MM charge and X2C correction are used together, function mm_charge
        needs to be applied after X2C decoration (.x2c method), eg
        mf = mm_charge(scf.RHF(mol).x2c()), [(0.5,0.6,0.8)], [-0.5]).
        2. Once mm_charge function is applied on the SCF object, it
        affects all the post-HF calculations eg MP2, CCSD, MCSCF etc

    Examples:

    >>> mol = gto.M(atom='H 0 0 0; F 0 0 1', basis='ccpvdz', verbose=0)
    >>> mf = mm_charge(dft.RKS(mol), [(0.5,0.6,0.8)], [-0.3])
    >>> mf.kernel()
    -101.940495711284
    '''
    mol = scf_method.mol
    if unit is None:
        unit = mol.unit
    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, a, charges,
                                   radii=radii, unit=unit)
    return qmmm_for_scf(scf_method, mm_mol)

def qmmm_for_scf(scf_method, mm_mol):
    assert isinstance(scf_method, scf.hf.SCF)

    if isinstance(scf_method, scf.hf.SCF):
        # Avoid to initialize _QMMM twice
        if isinstance(scf_method, _QMMM):
            scf_method.mm_mol = mm_mol
            return scf_method

        method_class = scf_method.__class__

    else:
        if isinstance(scf_method._scf, _QMMM):
            scf_method._scf.mm_mol = mm_mol
            return scf_method

        method_class = scf_method._scf.__class__

    class QMMM(_QMMM, method_class):
        def __init__(self, scf_method, mm_mol):
            self.__dict__.update(scf_method.__dict__)
            self.mm_mol = mm_mol
            self.mm_ewald_pot = None
            self._keys.update(['mm_mol'])
            self._keys.update(['mm_ewald_pot'])

        def dump_flags(self, verbose=None):
            method_class.dump_flags(self, verbose)
            logger.info(self, '** Add background charges for %s **',
                        method_class)
            _a = self.mm_mol.lattice_vectors()
            logger.info(self, 'lattice vectors  a1 [%.9f, %.9f, %.9f]', *_a[0])
            logger.info(self, '                 a2 [%.9f, %.9f, %.9f]', *_a[1])
            logger.info(self, '                 a3 [%.9f, %.9f, %.9f]', *_a[2])
            if self.verbose >= logger.DEBUG:
                logger.debug(self, 'Charge      Location')
                coords = self.mm_mol.atom_coords()
                charges = self.mm_mol.atom_charges()
                for i, z in enumerate(charges):
                    logger.debug(self, '%.9g    %s', z, coords[i])
            return self

        def get_hcore(self, mol=None, mm_ewal_pot=None):
            if mol is None:
                mol = self.mol
            mm_mol = self.mm_mol

            if getattr(method_class, 'get_hcore', None):
                h1e = method_class.get_hcore(self, mol)
            else:  # DO NOT modify post-HF objects to avoid the MM charges applied twice
                raise RuntimeError('mm_charge function cannot be applied on post-HF methods')

            coords = mm_mol.atom_coords()
            charges = mm_mol.atom_charges()
            nao = mol.nao
            max_memory = self.max_memory - lib.current_memory()[0]
            blksize = int(min(max_memory*1e6/8/nao**2, 200))
            blksize = max(blksize, 1)
            if mm_mol.charge_model == 'gaussian':
                expnts = mm_mol.get_zetas()

                if mol.cart:
                    intor = 'int3c2e_cart'
                else:
                    intor = 'int3c2e_sph'
                cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
                                                     mol._env, intor)
                v = 0
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
                    j3c = df.incore.aux_e2(mol, fakemol, intor=intor,
                                           aosym='s2ij', cintopt=cintopt)
                    v += lib.einsum('xk,k->x', j3c, -charges[i0:i1])
                v = lib.unpack_tril(v)
                h1e += v
            else:
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    j3c = mol.intor('int1e_grids', hermi=1, grids=coords[i0:i1])
                    h1e += lib.einsum('kpq,k->pq', j3c, -charges[i0:i1])
            return h1e

        def get_mm_ewald_pot(self, mol, mm_mol):
            return self.mm_mol.get_ewald_pot(
                mol.atom_coords(),
                mm_mol.atom_coords(), mm_mol.atom_charges())

        def get_qm_ewald_pot(self, mol, dm):
            ewald_pot = self.mm_mol.get_ewald_pot(mol.atom_coords())
            Q = self.get_qm_charges(dm)
            return lib.einsum('ij,j->i', ewald_pot, Q)

        def get_qm_charges(self, dm):
            aoslices = self.mol.aoslice_by_atom()
            chg = self.mol.atom_charges()
            dmS = lib.dot(dm, self.get_ovlp())
            qm_charges = list()
            for iatm in range(self.mol.natm):
                p0, p1 = aoslices[iatm, 2:]
                qm_charges.append(chg[iatm] - np.trace(dmS[p0:p1, p0:p1]))
            return np.asarray(qm_charges)

        def get_vdiff(self, mol, ewald_pot):
            '''
            vdiff_uv = d Q_I / d dm_uv ewald_pot_I
            '''
            vdiff = np.zeros((mol.nao, mol.nao))
            ovlp = self.get_ovlp()
            aoslices = mol.aoslice_by_atom()
            for iatm in range(mol.natm):
                v = ewald_pot[iatm] / 2
                p0, p1 = aoslices[iatm, 2:]
                vdiff[p0:p1] -= v * ovlp[p0:p1]
                vdiff[:,p0:p1] -= v * ovlp[:,p0:p1]
            return vdiff

        def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1, mm_ewald_pot=None):
            if mol is None:
                mol = self.mol
            mm_mol = self.mm_mol

            if mm_ewald_pot is None:
                if self.mm_ewald_pot is not None:
                    mm_ewald_pot = self.mm_ewald_pot
                else:
                    mm_ewald_pot = self.get_mm_ewald_pot(mol, mm_mol)
                    self.mm_ewald_pot = mm_ewald_pot

            ewald_pot = mm_ewald_pot + self.get_qm_ewald_pot(mol, dm)
            vdiff = self.get_vdiff(mol, ewald_pot)

            veff = method_class.get_veff(self, mol, dm, dm_last, vhf_last, hermi)
            return veff + vdiff

        def energy_elec(self, dm=None, h1e=None, vhf=None, mm_ewald_pot=None):
            if dm is None: dm = self.make_rdm1()
            elec = method_class.energy_elec(self, dm=dm, h1e=h1e, vhf=vhf)

            if mm_ewald_pot is None:
                if self.mm_ewald_pot is not None:
                    mm_ewald_pot = self.mm_ewald_pot
                else:
                    mm_ewald_pot = self.get_mm_ewald_pot(self.mol, self.mm_mol)
            ewald_pot = mm_ewald_pot + self.get_qm_ewald_pot(self.mol, dm)
            # QM-QM and QM-MM pbc correction
            elec += ewald_pot @ self.get_qm_charges(dm)
            return elec

        def energy_nuc(self):
            # gas phase nuc energy
            nuc = self.mol.energy_nuc()
            coords = self.mm_mol.atom_coords()
            charges = self.mm_mol.atom_charges()
            for j in range(self.mol.natm):
                q2, r2 = self.mol.atom_charge(j), self.mol.atom_coord(j)
                r = lib.norm(r2-coords, axis=1)
                nuc += q2*(charges/r).sum()
            return nuc

        def nuc_grad_method(self):
            pass

    if isinstance(scf_method, scf.hf.SCF):
        return QMMM(scf_method, mm_mol)
    else:
        scf_method._scf = QMMM(scf_method._scf, mm_mol).run()
        scf_method.mo_coeff = scf_method._scf.mo_coeff
        scf_method.mo_energy = scf_method._scf.mo_energy
        return scf_method

# A tag to label the derived class
class _QMMM:
    pass
class _QMMMGrad:
    pass