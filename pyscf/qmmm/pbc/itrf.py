import numpy as np
import pyscf
from pyscf import lib
from pyscf import gto
from pyscf import df
from pyscf import scf
from pyscf import grad
from pyscf.lib import logger
from pyscf.qmmm.pbc import mm_mole

import scipy

def add_mm_charges(scf_method, atoms_or_coords, a, charges, radii=None, unit=None):
    '''Embedding the one-electron (non-relativistic) potential generated by MM
    point charges into QM Hamiltonian.

    The total energy includes the regular QM energy, the interaction between
    the nuclei in QM region and the MM charges, and the static Coulomb
    interaction between the electron density and the MM charges. The electrostatic
    interactions between reference cell and periodic images are also computed at
    point charge level. It does not include the static Coulomb interactions 
    of the MM point charges, the MM energy, the vdw interaction or other 
    bonding/non-bonding effects between QM region and MM particles.

    Args:
        scf_method : a HF or DFT object

        atoms_or_coords : 2D array, shape (N,3)
            MM particle coordinates
        charges : 1D array
            MM particle charges
        a : 2D array, shape (3,3)
            Lattice vectors

    Kwargs:
        radii : 1D array
            The Gaussian charge distribution radii of MM atoms.
        unit : str
            Bohr, AU, Ang (case insensitive). Default is the same to mol.unit

    Returns:
        Same method object as the input scf_method with modified 1e Hamiltonian

    Note:
        1. if MM charge and X2C correction are used together, function mm_charge
        needs to be applied after X2C decoration (.x2c method), eg
        mf = mm_charge(scf.RHF(mol).x2c()), [(0.5,0.6,0.8)], [-0.5]).
        2. Once mm_charge function is applied on the SCF object, it
        affects all the post-HF calculations eg MP2, CCSD, MCSCF etc

    Examples:

    >>> mol = gto.M(atom='H 0 0 0; F 0 0 1', basis='ccpvdz', verbose=0)
    >>> mf = add_mm_charges(dft.RKS(mol), [(0.5,0.6,0.8)], np.eye(3)*10, [-0.3])
    >>> mf.kernel()
    -99.81024850171646
    '''
    mol = scf_method.mol
    if unit is None:
        unit = mol.unit
    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, a, charges,
                                   radii=radii, unit=unit)
    return qmmm_for_scf(scf_method, mm_mol)

def qmmm_for_scf(scf_method, mm_mol):
    assert isinstance(scf_method, scf.hf.SCF)

    if isinstance(scf_method, scf.hf.SCF):
        # Avoid to initialize _QMMM twice
        if isinstance(scf_method, _QMMM):
            scf_method.mm_mol = mm_mol
            return scf_method

        method_class = scf_method.__class__

    else:
        if isinstance(scf_method._scf, _QMMM):
            scf_method._scf.mm_mol = mm_mol
            return scf_method

        method_class = scf_method._scf.__class__

    class QMMM(_QMMM, method_class):
        def __init__(self, scf_method, mm_mol):
            self.__dict__.update(scf_method.__dict__)
            self.mm_mol = mm_mol
            self.mm_ewald_pot = None
            self.qm_ewald_hess = None
            self._keys.update(['mm_mol'])
            self._keys.update(['mm_ewald_pot'])
            self._keys.update(['qm_ewald_hess'])

        def dump_flags(self, verbose=None):
            method_class.dump_flags(self, verbose)
            logger.info(self, '** Add background charges for %s **',
                        method_class)
            _a = self.mm_mol.lattice_vectors()
            logger.info(self, 'lattice vectors  a1 [%.9f, %.9f, %.9f]', *_a[0])
            logger.info(self, '                 a2 [%.9f, %.9f, %.9f]', *_a[1])
            logger.info(self, '                 a3 [%.9f, %.9f, %.9f]', *_a[2])
            if self.verbose >= logger.DEBUG:
                logger.debug(self, 'Charge      Location')
                coords = self.mm_mol.atom_coords()
                charges = self.mm_mol.atom_charges()
                for i, z in enumerate(charges):
                    logger.debug(self, '%.9g    %s', z, coords[i])
            return self

        def get_hcore(self, mol=None):
            if mol is None:
                mol = self.mol
            mm_mol = self.mm_mol

            if getattr(method_class, 'get_hcore', None):
                h1e = method_class.get_hcore(self, mol)
            else:  # DO NOT modify post-HF objects to avoid the MM charges applied twice
                raise RuntimeError('mm_charge function cannot be applied on post-HF methods')

            coords = mm_mol.atom_coords()
            charges = mm_mol.atom_charges()
            nao = mol.nao
            max_memory = self.max_memory - lib.current_memory()[0]
            blksize = int(min(max_memory*1e6/8/nao**2, 200))
            blksize = max(blksize, 1)
            if mm_mol.charge_model == 'gaussian':
                expnts = mm_mol.get_zetas()

                if mol.cart:
                    intor = 'int3c2e_cart'
                else:
                    intor = 'int3c2e_sph'
                cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
                                                     mol._env, intor)
                v = 0
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
                    j3c = df.incore.aux_e2(mol, fakemol, intor=intor,
                                           aosym='s2ij', cintopt=cintopt)
                    v += lib.einsum('xk,k->x', j3c, -charges[i0:i1])
                v = lib.unpack_tril(v)
                h1e += v
            else:
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    j3c = mol.intor('int1e_grids', hermi=1, grids=coords[i0:i1])
                    h1e += lib.einsum('kpq,k->pq', j3c, -charges[i0:i1])
            return h1e

        def get_mm_ewald_pot(self, mol, mm_mol):
            return self.mm_mol.get_ewald_pot(
                mol.atom_coords(),
                mm_mol.atom_coords(), mm_mol.atom_charges())

        def get_qm_ewald_pot(self, mol, dm):
            # d^2 Epbc / dq_i dq_j
            self.qm_ewald_hess = self.mm_mol.get_ewald_pot(mol.atom_coords())
            Q = self.get_qm_charges(dm)
            return lib.einsum('ij,j->i', self.qm_ewald_hess, Q)

        def get_qm_charges(self, dm):
            aoslices = self.mol.aoslice_by_atom()
            chg = self.mol.atom_charges()
            dmS = lib.dot(dm, self.get_ovlp())
            qm_charges = list()
            for iatm in range(self.mol.natm):
                p0, p1 = aoslices[iatm, 2:]
                qm_charges.append(chg[iatm] - np.trace(dmS[p0:p1, p0:p1]))
            return np.asarray(qm_charges)

        def get_vdiff(self, mol, ewald_pot):
            '''
            vdiff_uv = d Q_I / d dm_uv ewald_pot_I
            '''
            vdiff = np.zeros((mol.nao, mol.nao))
            ovlp = self.get_ovlp()
            aoslices = mol.aoslice_by_atom()
            for iatm in range(mol.natm):
                v = ewald_pot[iatm] / 2
                p0, p1 = aoslices[iatm, 2:]
                vdiff[p0:p1] -= v * ovlp[p0:p1]
                vdiff[:,p0:p1] -= v * ovlp[:,p0:p1]
            return vdiff

        def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1,
                     mm_ewald_pot=None, qm_ewald_pot=None):
            if mol is None:
                mol = self.mol
            mm_mol = self.mm_mol

            if mm_ewald_pot is None:
                if self.mm_ewald_pot is not None:
                    mm_ewald_pot = self.mm_ewald_pot
                else:
                    mm_ewald_pot = self.get_mm_ewald_pot(mol, mm_mol)
                    self.mm_ewald_pot = mm_ewald_pot
            if qm_ewald_pot is None:
                if self.qm_ewald_hess is not None:
                    qm_ewald_pot = lib.einsum('ij,j->i',
                                    self.qm_ewald_hess, self.get_qm_charges(dm))
                else:
                    qm_ewald_pot = self.get_qm_ewald_pot(mol, dm)

            ewald_pot = mm_ewald_pot + qm_ewald_pot
            vdiff = self.get_vdiff(mol, ewald_pot)

            veff = method_class.get_veff(self, mol, dm, dm_last, vhf_last, hermi)
            if isinstance(veff, lib.NPArrayWithTag):
                metadata = veff.__dict__
                veff = lib.tag_array(veff + vdiff, veff_rs=veff, **metadata)
            else:
                veff = lib.tag_array(veff + vdiff, veff_rs=veff)
            return veff

        def energy_elec(self, dm=None, h1e=None, vhf=None):
            if vhf is None:
                # use the original veff to compute energy
                vhf = method_class.get_veff(self, self.mol, dm)
                return method_class.energy_elec(self, dm=dm, h1e=h1e, vhf=vhf)
            else:
                return method_class.energy_elec(self, dm=dm, h1e=h1e, vhf=vhf.veff_rs)

        def energy_ewald(self, dm=None, mm_ewald_pot=None, qm_ewald_pot=None):
            # QM-QM and QM-MM pbc correction
            if mm_ewald_pot is None:
                if self.mm_ewald_pot is not None:
                    mm_ewald_pot = self.mm_ewald_pot
                else:
                    mm_ewald_pot = self.get_mm_ewald_pot(self.mol, self.mm_mol)
            if qm_ewald_pot is None:
                if self.qm_ewald_hess is not None:
                    qm_ewald_pot = lib.einsum('ij,j->i',
                                    self.qm_ewald_hess, self.get_qm_charges(dm))
                else:
                    qm_ewald_pot = self.get_qm_ewald_pot(self.mol, dm)
            ewald_pot = mm_ewald_pot + qm_ewald_pot / 2
            return ewald_pot @ self.get_qm_charges(dm)

        def energy_nuc(self):
            # gas phase nuc energy
            nuc = self.mol.energy_nuc()
            coords = self.mm_mol.atom_coords()
            charges = self.mm_mol.atom_charges()
            for j in range(self.mol.natm):
                q2, r2 = self.mol.atom_charge(j), self.mol.atom_coord(j)
                r = lib.norm(r2-coords, axis=1)
                nuc += q2*(charges/r).sum()
            return nuc

        def energy_tot(self, dm=None, h1e=None, vhf=None, mm_ewald_pot=None, qm_ewald_pot=None):
            nuc = self.energy_nuc()
            ewald = self.energy_ewald(dm=dm, mm_ewald_pot=mm_ewald_pot, qm_ewald_pot=qm_ewald_pot)
            e_tot = self.energy_elec(dm, h1e, vhf)[0] + nuc + ewald
            self.scf_summary['nuc'] = nuc.real
            self.scf_summary['ewald'] = ewald
            return e_tot

        def nuc_grad_method(self):
            scf_grad = method_class.nuc_grad_method(self)
            return qmmm_grad_for_scf(scf_grad)
        Gradients = nuc_grad_method

    if isinstance(scf_method, scf.hf.SCF):
        return QMMM(scf_method, mm_mol)
    else:
        scf_method._scf = QMMM(scf_method._scf, mm_mol).run()
        scf_method.mo_coeff = scf_method._scf.mo_coeff
        scf_method.mo_energy = scf_method._scf.mo_energy
        return scf_method

def add_mm_charges_grad(scf_grad, atoms_or_coords, a, charges, radii=None, unit=None):
    '''Apply the MM charges in the QM gradients' method.  It affects both the
    electronic and nuclear parts of the QM fragment.

    Args:
        scf_grad : a HF or DFT gradient object (grad.HF or grad.RKS etc)
            Once the add_mm_charges_grad was applied, it affects all post-HF
            calculations eg MP2, CCSD, MCSCF etc
        coords : 2D array, shape (N,3)
            MM particle coordinates
        charges : 1D array
            MM particle charges
        a : 2D array, shape (3,3)
            Lattice vectors
    Kwargs:
        radii : 1D array
            The Gaussian charge distribution radii of MM atoms.
        unit : str
            Bohr, AU, Ang (case insensitive). Default is the same to mol.unit

    Returns:
        Same gradeints method object as the input scf_grad method

    Examples:

    >>> from pyscf import gto, scf, grad
    >>> mol = gto.M(atom='H 0 0 0; F 0 0 1', basis='ccpvdz', verbose=0)
    >>> mf = mm_charge(scf.RHF(mol), [(0.5,0.6,0.8)], [-0.3])
    >>> mf.kernel()
    -101.940495711284
    >>> hfg = mm_charge_grad(grad.hf.RHF(mf), coords, charges)
    >>> hfg.kernel()
    [[-0.25912357 -0.29235976 -0.38245077]
     [-1.70497052 -1.89423883  1.2794798 ]]
    '''
    assert (isinstance(scf_grad, grad.rhf.Gradients))
    mol = scf_grad.mol
    if unit is None:
        unit = mol.unit
    mm_mol = mm_mole.create_mm_mol(atoms_or_coords, a, charges,
                                   radii=radii, unit=unit)
    mm_grad = qmmm_grad_for_scf(scf_grad)
    mm_grad.base.mm_mol = mm_mol
    return mm_grad

# Define method mm_charge_grad for backward compatibility
mm_charge_grad = add_mm_charges_grad

def qmmm_grad_for_scf(scf_grad):
    '''Add the potential of MM particles to SCF (HF and DFT) object and then
    generate the corresponding QM/MM gradients method for the QM system.
    '''
    if getattr(scf_grad.base, 'with_x2c', None):
        raise NotImplementedError('X2C with QM/MM charges')

    # Avoid to initialize _QMMMGrad twice
    if isinstance(scf_grad, _QMMMGrad):
        return scf_grad

    assert (isinstance(scf_grad.base, scf.hf.SCF) and
           isinstance(scf_grad.base, _QMMM))

    grad_class = scf_grad.__class__
    class QMMM(_QMMMGrad, grad_class):
        def __init__(self, scf_grad):
            self.__dict__.update(scf_grad.__dict__)

        def dump_flags(self, verbose=None):
            grad_class.dump_flags(self, verbose)
            logger.info(self, '** Add background charges for %s **', grad_class)
            _a = self.base.mm_mol.lattice_vectors()
            logger.info(self, 'lattice vectors  a1 [%.9f, %.9f, %.9f]', *_a[0])
            logger.info(self, '                 a2 [%.9f, %.9f, %.9f]', *_a[1])
            logger.info(self, '                 a3 [%.9f, %.9f, %.9f]', *_a[2])
            if self.verbose >= logger.DEBUG1:
                logger.debug1(self, 'Charge      Location')
                coords = self.base.mm_mol.atom_coords()
                charges = self.base.mm_mol.atom_charges()
                for i, z in enumerate(charges):
                    logger.debug1(self, '%.9g    %s', z, coords[i])
            return self

        def get_hcore(self, mol=None):
            ''' (QM 1e grad) + <-d/dX i|q_mm/r_mm|j>'''
            if mol is None:
                mol = self.mol
            mm_mol = self.base.mm_mol
            coords = mm_mol.atom_coords()
            charges = mm_mol.atom_charges()

            nao = mol.nao
            max_memory = self.max_memory - lib.current_memory()[0]
            blksize = int(min(max_memory*1e6/8/nao**2/3, 200))
            blksize = max(blksize, 1)
            g_qm = grad_class.get_hcore(self, mol)
            if mm_mol.charge_model == 'gaussian':
                expnts = mm_mol.get_zetas()
                if mol.cart:
                    intor = 'int3c2e_ip1_cart'
                else:
                    intor = 'int3c2e_ip1_sph'
                cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
                                                     mol._env, intor)
                v = 0
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
                    j3c = df.incore.aux_e2(mol, fakemol, intor, aosym='s1',
                                           comp=3, cintopt=cintopt)
                    v += lib.einsum('ipqk,k->ipq', j3c, charges[i0:i1])
                g_qm += v
            else:
                for i0, i1 in lib.prange(0, charges.size, blksize):
                    j3c = mol.intor('int1e_grids_ip', grids=coords[i0:i1])
                    g_qm += lib.einsum('ikpq,k->ipq', j3c, charges[i0:i1])
            return g_qm

        def grad_hcore_mm(self, dm, mol=None):
            r'''Nuclear gradients of the electronic energy
            with respect to MM atoms:

            ... math::
                g = \sum_{ij} \frac{\partial hcore_{ij}}{\partial R_{I}} P_{ji},

            where I represents MM atoms.

            Args:
                dm : array
                    The QM density matrix.
            '''
            if mol is None:
                mol = self.mol
            mm_mol = self.base.mm_mol

            coords = mm_mol.atom_coords()
            charges = mm_mol.atom_charges()
            expnts = mm_mol.get_zetas()

            intor = 'int3c2e_ip2'
            nao = mol.nao
            max_memory = self.max_memory - lib.current_memory()[0]
            blksize = int(min(max_memory*1e6/8/nao**2/3, 200))
            blksize = max(blksize, 1)
            cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas,
                                                 mol._env, intor)

            g = np.empty_like(coords)
            for i0, i1 in lib.prange(0, charges.size, blksize):
                fakemol = gto.fakemol_for_charges(coords[i0:i1], expnts[i0:i1])
                j3c = df.incore.aux_e2(mol, fakemol, intor, aosym='s1',
                                       comp=3, cintopt=cintopt)
                g[i0:i1] = lib.einsum('ipqk,qp->ik', j3c * charges[i0:i1], dm).T
            return g

        contract_hcore_mm = grad_hcore_mm # for backward compatibility

        def grad_nuc(self, mol=None, atmlst=None, dm=None):
            if mol is None: mol = self.mol
            coords = self.base.mm_mol.atom_coords()
            charges = self.base.mm_mol.atom_charges()

            # gas phase nuc interactions
            g_qm = grad_class.grad_nuc(self, mol, atmlst)
# nuclei lattice interaction
            g_mm = np.empty((mol.natm,3))
            for i in range(mol.natm):
                q1 = mol.atom_charge(i)
                r1 = mol.atom_coord(i)
                r = lib.norm(r1-coords, axis=1)
                g_mm[i] = -q1 * lib.einsum('i,ix,i->x', charges, r1-coords, 1/r**3)
            if atmlst is not None:
                g_mm = g_mm[atmlst]

            return g_qm + g_mm

        def grad_nuc_mm(self, mol=None):
            '''Nuclear gradients of the gas-phase QM-MM nuclear energy
            (in the form of point charge Coulomb interactions)
            with respect to MM atoms.
            '''
            if mol is None:
                mol = self.mol
            mm_mol = self.base.mm_mol
            coords = mm_mol.atom_coords()
            charges = mm_mol.atom_charges()
            g_mm = np.zeros_like(coords)
            for i in range(mol.natm):
                q1 = mol.atom_charge(i)
                r1 = mol.atom_coord(i)
                r = lib.norm(r1-coords, axis=1)
                g_mm += q1 * lib.einsum('i,ix,i->ix', charges, r1-coords, 1/r**3)
            return g_mm

        def grad_ewald_all(self, dm=None):
            # pbc correction grad w.r.t. qm and mm atom positions
            if dm is None: dm = self.base.make_rdm1()
            qm_charges = self.base.get_qm_charges(dm)
            qm_coords = self.base.mol.atom_coords()
            mm_charges = self.base.mm_mol.atom_charges()
            mm_coords = self.base.mm_mol.atom_coords()
            cell = self.base.mm_mol
            assert cell.dimension == 3
            ew_eta = cell.get_ewald_params()[0]
            Lall = cell.get_lattice_Ls()

            def loop(i):
                for j in range(len(qm_coords)):
                    if j == i:
                        continue
                    else:
                        yield j, qm_charges[j], qm_coords[j], False
                for j in range(len(mm_coords)):
                    yield j, mm_charges[j], mm_coords[j], True

            qm_ewovrl_grad = np.zeros_like(qm_coords)
            mm_ewovrl_grad = np.zeros_like(mm_coords)
            for i, qi in enumerate(qm_charges):
                ri = qm_coords[i]
                for j, qj, rj, is_mm in loop(i):
                    r1 = ri-rj + Lall
                    r = np.sqrt(np.einsum('ji,ji->j', r1, r1))
                    r = r.reshape(len(r),1)
                    grad_i = np.sum(+ (qi * qj / r ** 3 * r1 *
                                    scipy.special.erf(ew_eta * r).reshape(len(r),1)), axis = 0) + \
                             np.sum(- qi * qj / r ** 2 * r1 * 2 * ew_eta / np.sqrt(np.pi) *
                                 np.exp(-ew_eta**2 * r ** 2).reshape(len(r),1), axis = 0)
                    qm_ewovrl_grad[i] += grad_i
                    if is_mm:
                        mm_ewovrl_grad[j] -= grad_i

            qm_ewg_grad = np.zeros_like(qm_coords)
            mm_ewg_grad = np.zeros_like(mm_coords)

            mesh = pyscf.pbc.gto.cell._cut_mesh_for_ewald(cell, cell.mesh)
            Gv, Gvbase, weights = cell.get_Gv_weights(mesh)
            absG2 = lib.einsum('gi,gi->g', Gv, Gv)
            absG2[absG2==0] = 1e200
            qm_SI = cell.get_SI(Gv, coords=qm_coords)
            mm_SI = cell.get_SI(Gv, coords=mm_coords)
            qm_ZSI = lib.einsum('i,ig->g', qm_charges, qm_SI)
            mm_ZSI = lib.einsum('i,ig->g', mm_charges, mm_SI)
            coulG = 4*np.pi / absG2
            coulG *= weights
            ZexpG2 = coulG * np.exp(-absG2/(4*ew_eta**2))
            ZexpG2_mod = ZexpG2.reshape(len(ZexpG2),1) * Gv # Ngrid x 3
            for i, qi in enumerate(qm_charges):
                Zfac = np.imag( (mm_ZSI+qm_ZSI) * qm_SI[i].conj()) * qi
                qm_ewg_grad[i] = - np.sum(Zfac.reshape((len(Zfac),1)) * ZexpG2_mod, axis = 0)
            for i, qi in enumerate(mm_charges):
                Zfac = np.imag(qm_ZSI * mm_SI[i].conj()) * qi
                mm_ewg_grad[i] = + np.sum(Zfac.reshape((len(Zfac),1)) * ZexpG2_mod, axis = 0)

            return qm_ewg_grad + qm_ewovrl_grad, mm_ewg_grad + mm_ewovrl_grad
    return QMMM(scf_grad)

# A tag to label the derived class
class _QMMM:
    pass
class _QMMMGrad:
    pass
